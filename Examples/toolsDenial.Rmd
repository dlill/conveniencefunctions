---
title: "d2d2r"
author: "Daniel Lill"
date: "13 October 2017"
output: html_document
---

```{r, message=FALSE}
library(dMod)
devtools::load_all("~/Promotion/Software/dMod/")
library(stringr)
library(conveniencefunctions)
# library(magrittr)
#' importFrom magrittr "%>%"
"%>%" <- magrittr::"%>%"

library(tidyverse)
library(magrittr)
```

```{r}
model_def_file <- "~/Promotion/Projects/TGFb/Feedbackmodel/15_V20/Models/TGFbSmad16_hepa16_2miRNA.def"
data_files <- list.files("~/Promotion/Projects/TGFb/Feedbackmodel/15_V20/Data/") %>% 
  {.[str_detect(.,"def$")]} %>% 
  {.} %>% 
  str_replace_all(c("\\.def" = "")) %>% 
  matrix(., ncol = 3, nrow = length(.)) %>% 
  {.[,3] <- "xls";.}

setup_file = NULL

```

```{r}
trafos <- lapply(seq_along(observables), function(i) {
  # Foreplay
  model_cond <- get_conditions(model_def)
  data_cond <- get_conditions(data_defs[[i]])

  # construct the trafo
  trafo <- c(names(f), # 1. Make a identity-trafo in which the transformed parameters will be replaced successively
    getSymbols(f),
    getSymbols(observables[[i]]),
    getSymbols(errors[[i]])
  ) %>% 
    unique %>% 
    structure(.,names = .) %>% 
    replace(.,names(model_cond), model_cond) %>%  # 2. Replace parameters by the parameters given in model_def$conditions
    replace(.,names(data_cond), data_cond)  # 3. Replace parameters by the parameters given in data_def$conditions
  
  return(trafo)
})
```

```{r}
  # 4. Read data_xls, append file name as its own column to distinguish between different data_defs, turn data sheet objects into datalists. 
  # This gives the condition.grid which contains all conditions specified by the data sets.
  
  # It happened already that some observables were commented out in the data_def, but were still present in the data sheet.
  # Kick out all columns which don't define any observables, parameters or time or RANDOM_ids
  random_ids <- get_random(model_def) %>% c(lapply(data_defs,. %>% get_random) %>% do.call(c,.)) %>% unique
  
  mydatalist <-  NULL
  mydatalist <- lapply(seq_along(data_sheets), function(i) {
    
    observable_names <- names(observables[[i]])
    mytrafo <- trafos[[i]]
    mynames <- names(data_sheets[[i]]) %>% str_replace("^init_", "")
    
    undefined_cols <- mynames[!(mynames%in%c(observable_names, getSymbols(c(mytrafo, names(mytrafo))), "time")) &
                                !(mynames %>% sapply(. %>% str_detect(random_ids) %>% any))]
    if (length(undefined_cols)>0) warning("Columns ", paste(undefined_cols, collapse = "\n"), " were kicked out from data sheet ", i, ": ", data_files[i,1], "\n\n")
    
    if (any(str_detect(names(data_sheets[[i]]), "_std"))) warning("std supplied in data sheet not yet implemented.")
    
    data_sheets[[i]] %>% 
    {.[!(names(.) %in% undefined_cols)]} %>% #kick out undefined cols
      tidyr::gather_(., key_col = "name", value = "value", gather_cols = names(observables[[i]])[names(observables[[i]]) %in% names(.)], na.rm = T) %>% # tidy the data into the dMod-style, name, time, value, sigma, (additional cols which define the condition)
      cbind(sigma = NA, data_file = paste0(i)) %>% 
      {names(.) <- names(.) %>% str_replace("^init_", "")
      .}
  }) %>% 
    plyr::join_all(., type = "full") %>% 
    as.datalist()
```


```{r}  
  cg <- mydatalist %>% attr("condition.grid")
  
  # 5. Insert parameter values given in the data sheet into the parameter trafos
  # Make a comprehensive list of parameter trafos for all conditions specified in the condition.grid
  cg_which_random <- names(cg) %>% sapply(. %>% str_detect(random_ids)%>% any)
  cg_random <- cg[cg_which_random]
  cg_pars <- cg[!(cg_which_random|str_detect(names(cg),"data_file"))]
```


```{r}  
  trafo_list <-  list()
  trafo_list <- lapply(1:nrow(cg), function(i) {
    
    mytrafo <- trafos[[as.integer(cg[["data_file"]][i])]]
    mytrafo_names <- names(mytrafo) # I need that, because str_ somehow kills the names
    
    # Deal with RANDOM pars
    # They are most likely to appear in sd and offset pars. Kill (ie set to 1) all "random" pars which don't contain an observed observable in the respective experiment
    random_id_values <- cg_random[i,,drop = F] %>% unlist
    observed <- mydatalist[[i]]$name %>% unique
    mytrafo[(!sapply(mytrafo, . %>% str_detect(observed) %>% any)) & 
            sapply(mytrafo, . %>% str_detect(names(random_id_values)) %>% any)] <- "1"
    
    if(any(is.na(random_id_values))) warning("random ids are NA.")
    what <- paste0("([\b_]*)(?:", names(random_id_values),")([\b_]*)")
    by <- paste0("\\1", names(random_id_values),  random_id_values)
    replace_vec <- structure(by, names = what)
    if(length(replace_vec)>0) {
      mytrafo <-
        mytrafo %>% str_replace_all(replace_vec) %>% {names(.) <- mytrafo_names;.}
    }
    # str_replace("abcdefg", "(ab)(?:cd)", "\\1hij") # to understand the upper regex
    
    
    # Deal with parameter values specified in the data sheet
    # Because of having multiple data sheets, some of these parameters can be NA, ie not specified in this data sheet.
    mycg_pars <- cg_pars[i,,drop = F] %>% unlist()
    # There are pars which are already replaced by a numeric value, these cannot be replaced by str_replace.
    is_already_set <- names(mycg_pars) %>% sapply(. %>% paste0("\\b", ., "\\b") %>% str_detect(mytrafo,.) %>% any %>% {!.} )
    if(any((!is_already_set)&(!is.na(mycg_pars)))) {
      what <- paste0("\\b",names(mycg_pars)[(!is_already_set)&(!is.na(mycg_pars))], "\\b")
      by <- as.character(mycg_pars)[(!is_already_set)&(!is.na(mycg_pars))]
      replace_vec <- structure(by, names = what)
      if (length(replace_vec)>0) {
        mytrafo <- mytrafo %>% str_replace_all(replace_vec) %>% {names(.) <- mytrafo_names;.}
      } 
    }
    # Replace all remaining pars by accessing them directly
    mytrafo[names(mycg_pars[is_already_set&(!is.na(mycg_pars))])] <- mycg_pars[is_already_set&(!is.na(mycg_pars))]
    
    return(mytrafo)
  }) %>% structure(., names = rownames(cg))
```


```{r}
 trafo_list <- lapply(1:nrow(cg), function(i) {
    
    mytrafo <- trafos[[as.integer(cg[["data_file"]][i])]]
    mytrafo_names <- names(mytrafo) # I need that, because str_ somehow kills the names
    # Deal with RANDOM pars
    random_id_values <- cg_random[i,,drop = F] %>% unlist
    if(any(is.na(random_id_values))) warning("random ids are NA.")
    what <- paste0("([\b_]*)(?:", names(random_id_values),")([\b_]*)")
    by <- paste0("\\1", names(random_id_values),  random_id_values)
    replace_vec <- structure(by, names = what)
    if(length(replace_vec)>0) {
      mytrafo <-
        mytrafo %>% str_replace_all(replace_vec) %>% {names(.) <- mytrafo_names;.}
    }
    # str_replace("abcdefg", "(ab)(?:cd)", "\\1hij") # to understand the upper regex
    
    
    # Deal with parameter values specified in the data sheet
    # Because of having multiple data sheets, some of these parameters can be NA, ie not specified in this data sheet.
    mycg_pars <- cg_pars[i,,drop = F] %>% unlist()
    # There are pars which are already replaced by a numeric value, these cannot be replaced by str_replace.
    is_already_set <- names(mycg_pars) %>% sapply(. %>% paste0("\\b", ., "\\b") %>% str_detect(mytrafo,.) %>% any %>% {!.} )
    what <- paste0("\\b",names(mycg_pars)[(!is_already_set)&(!is.na(mycg_pars))], "\\b")
    by <- as.character(mycg_pars)[(!is_already_set)&(!is.na(mycg_pars))]
    replace_vec <- structure(by, names = what)
    if (length(replace_vec)>0) {
      mytrafo <- mytrafo %>% str_replace_all(replace_vec) %>% {names(.) <- mytrafo_names;.}
    } 
    # Replace all remaining pars by accessing them directly
    mytrafo[names(mycg_pars[is_already_set&(!is.na(mycg_pars))])] <- mycg_pars[is_already_set&(!is.na(mycg_pars))]
    
    return(mytrafo)
  }) %>% structure(., names = rownames(cg))
```

```{r}
trafos    %>% sapply(. %>% length) %>% unname()
trafo_list %>% sapply(. %>% length) %>% unname()
```

```{r}
mytrafo %>% str_detect(what) %>% sum
```


# Setup.m
```{r}
# setup_file <- "Models/TGFb_ComplexModel_ModelSelection_L1/Setup_ModelSelectionProfile2_L1_1eM10.m"
setup_file <- "Models/TGFb_ComplexModel_withGenes/Setup.m"
model_def_file <- NULL
data_files <- NULL
readme_file <- NULL
# data_files <- readLines(setup_file) %>% {.[!str_detect(.,"^%")]} %>% {.[str_detect(.,"arLoadData")]} %>% str_replace_all(c("arLoadData\\(" = "", "\\)" = "", "'" = "")) %>% str_split(",", simplify = T)


```

# understand P

```{r}
# Define a time grid on which to make a prediction by peace-wise linear function.
# Then define a (generic) prediction function based on thid grid.
times <- 0:5
grid <- data.frame(name = "A", time = times, row.names = paste0("p", times))
x <- Xd(grid)

# Define an observable and an observation function
observables <- eqnvec(Aobs = "s*A")
g <- Y(g = observables, f = NULL, states = "A", parameters = "s")

# Collect parameters and define an overarching parameter transformation
# for two "experimental condtions".
dynpars <- attr(x, "parameters")
obspars <- attr(g, "parameters")
innerpars <- c(dynpars, obspars)

trafo <- structure(innerpars, names = innerpars)
trafo_C1 <- replaceSymbols(innerpars, paste(innerpars, "C1", sep = "_"), trafo)
trafo_C2 <- replaceSymbols(innerpars, paste(innerpars, "C2", sep = "_"), trafo)

p <- NULL
p <- p + P(trafo = trafo_C1, condition = "C1")
p <- p + P(trafo = trafo_C2, condition = "C2")

outerpars <- attr(p, "parameters")
pars <- structure(runif(length(outerpars), 0, 1), names = outerpars)

# Predict internal/unobserved states
 (x*p)(times,pars[1:7], conditions = "C1") %>% lapply(. %>% attributes)


```


```{r}
errors %>% get

myeqnlist0 %>% head()
myeqnlist %>% head()
```




# Readme.txt
To get fitted parameters
```{r}
readme_file <- "Models/TGFb_ComplexModel_withGenes/Readme.txt"

pars_fitted <- get_fitted_pars_from_readme(readme_file)
pouter <- pars_fitted$value %>% set_names(pars_fitted$name)

```

# Choose the data set
```{r}
modelpath <- "Models/TGFb_ComplexModel_withGenes/"

model_def_file <- paste0(modelpath, "Models/Complex_ModelSelectionProfile.def")
data_def_file <- paste0(modelpath, "Data/", data_files[6,1], ".def")
data_xls_file <- paste0(modelpath, "Data/", data_files[6,1], ".", data_files[6,3])

```




Now, read the model_def and data_def.
Overwrite the respective things from the model_def with the things from data_def.
```{r}
model_def <- read_def_content(model_def_file)
data_defs <- data_def_files %>%  lapply(. %>% read_def_content)
model_def %>% attr("is_data")
data_def %>% attr("is")
```

# x
x can only be obtained by model_def
```{r}
reactions <- get_reactions_or_odes(model_def)
if(is.eqnlist(reactions)) {
  f <- as.eqnvec(reactions)
} else {
  f <- reactions
}

# myodemodel <- odemodel(f)
# save(myodemodel, file = "myodemodel.rda")
load("myodemodel.rda")
# myodemodel
x <- Xs(odemodel = myodemodel)
loadDLL(x)
# x(1:2, runif(length(getParameters(x))) %>% set_names(getParameters(x)), deriv = F)

# Parametergymnastik
pars_x <- getParameters(x)
init_pars <- names(f)
dyn_pars_x <- setdiff(pars_x, names(f))

```

# g
g can be obtained by both, model_def and data_def.
Read both, compare them
```{r}
observables <- get_observables(model_def)
obs_data_def <- get_observables(data_def)

observables <- replace(observables, names(obs_data_def), obs_data_def) %>% as.eqnvec()
# Maybe dMod's conditions could be used to get the different data_defs into one model?
# g <- Y(g = observables, f = f)
# save(g, file = "g.rda")
load("g.rda")
# Parametergymastik
pars_g <- getParameters(g)
pars_g_x <- getParameters(g*x)

```

# Error model
```{r}
errors <- get_errors(model_def)
errors_data_def <- get_errors(data_def)

errors <- replace(errors, names(errors_data_def), errors_data_def) %>% as.eqnvec()

# Maybe dMod's conditions could be used to get the different data_defs into one model?
errmodel <- Y(g = errors, f = c(f, observables))
```


# condition(s)
Tricky, since it has many layers!
* Setup.m specifies all data sets which are loaded in common
-> This creates the first layer of conditions

The data*.def conditions are then once again split up into these conditions:
* (PREDICTOR-)DOSERESPONSE is used to get parameter values directly from the data 
* CONDITION sets only one condition?
* RANDOM set more conditions at once

To deal with RANDOM pars

1. random pars werden in RANDOM definiert, zb nExpID. 
2. Im Modell steht dann ein parameter, zb k234_nExpID
3. dann wird das data.xls file gelesen, mit der spalte nExpID
4. das nExpID muss dann eingesetzt werden in die Parameternamen. dann hat man mehrere conditions
z.B. condition "2"
pinner = k234_nExpID
pouter = k234_2
-> p_random(c(k234_2 = 1)) = c(k234_nExpID = 1)

To deal with PREDICTOR-DOSERESPONSE is the same as dealing with parameters given in the data-sheet

To do: 
1. read data_def and model_def: get_random and parameters
2. read data_xls: which which parameters are supplied by the data?
```{r}
# The underlying trafo obtained from model_def and data_def
trafo <- union(getParameters((g*x)), getParameters(errmodel)) %>% structure(., names = .)

trafo_model_def <- get_conditions(model_def, states = get_states(model_def))
trafo_data_def <- get_conditions(data_def, states = get_states(model_def))
trafo_model_def <- replace(trafo_model_def, names(trafo_data_def), trafo_data_def)

# quick sanity check
if (any(!names(trafo_model_def) %in% trafo)) {
  warning("Parameters are specified in CONDITIONS which are not in all parameters of c(g,x,errmodel)")
}

trafo <- replace(trafo, names(trafo_model_def), trafo_model_def)

data_xls <- readxl::read_excel(data_xls_file) %>% 
  tidyr::gather_(key_col = "name", value = "value", gather_cols = names(observables), na.rm = T) %>% 
  cbind(sigma = NA, data_file = data_xls_file) 
# fix init_ in column names which supply parameter values
names(data_xls) <- names(data_xls) %>% str_replace("^init_", "")

mydatalist <- data_xls %>% as.datalist()
cg <- mydatalist %>% attr("condition.grid")

# debugging
# random_ids <- c("nExpID", "TGFb")
# i <- 1

random_ids <- get_random(model_def) %>% c(get_random(data_def)) %>% unique
cg_which_random <- names(cg) %>% sapply(. %>% str_detect(random_ids)%>% any)

cg_random <- cg[cg_which_random]
cg_pars <- cg[!(cg_which_random|str_detect(names(cg),"data_file"))]

trafo_list <- lapply(1:nrow(cg), function(i) {
  
  random_id_values <- cg_random[i,,drop = F] %>% unlist
  
  what <- paste0("\\1", names(random_id_values),  random_id_values)
  by <- paste0("([\b_]*)(?:", names(random_id_values),")([\b_]*)")
  mytrafo <-
    sapply(trafo, . %>% str_replace_all(structure(what, names = by)))
  # str_replace("abcdefg", "(ab)(?:cd)", "\\1hij") # to understand the upper regex

    
  mycg_pars <- cg_pars[i,,drop = F] %>% unlist()
  
  # There are pars which are already replaced by a numeric value
  # These cannot be replaced by str_replace
  is_already_set <- sapply(names(mycg_pars), . %>% paste0("\b", ., "\b")%>% str_detect(mytrafo) %>% any %>% {!.})
  mytrafo <- sapply(mytrafo, . %>% str_replace_all(structure(as.character(mycg_pars[!is_already_set]),
                                                             names = names(mycg_pars[!is_already_set]))))
  mytrafo[names(mycg_pars[is_already_set])] <- mycg_pars[is_already_set]
  
  return(mytrafo)
}) %>% structure(., names = rownames(cg))

p_grid <- NULL
for (i in 1:nrow(cg)) {
  print(i)
  p_grid <<- p_grid + P(trafo_list[[i]], condition = names(trafo_list)[i])
}
```


```{r}


observables_no_genes <- names(f)[1:21][-c(6,8,11,13,15,16,18,20)] %>% set_names(.,paste0(.,"."))  %>%  as.eqnvec()

# Maybe dMod's conditions could be used to get the different data_defs into one model?
g_no_genes <- Y(g = observables_no_genes, f = f, attach.input = F)
# save(g, file = "g.rda")
# load("g.rda")
# Parametergymastik
# pars_g <- getParameters(g)
# pars_g_x <- getParameters(g*x)

```


```{r}
mypars <- getParameters(p_grid)

pouternames <- names(pouter)

# pouternames[!(pouternames%in%mypars)]
# mypars[!(mypars%in%pouternames)]
# length(pouter)

# p_grid(pouter)[c(2,4,6,8)]

mypred <- (g_no_genes*x*p_grid)(seq(0,600,length.out = 100), pouter, deriv = F)

plotPrediction(mypred
               , condition %in% row.names(cg[cg$TGFb==1,])
               ) + 
  # geom_line(aes(linetype = condition, color = condition))+
  guides(color = F, linetype = F) 


```

```{r}
cg
```


# Scale molecules per cell data to model units

The model's units for the states are supposedly concentrations, nMol/l.
However, if one tries to compute the number of molecules per cell, this doesn't make sense.
```{r}
# states <- get_states(model_def)
compartments <- get_compartments(model_def)
compartments[c("name", "eqn")]
S2tot_wt <- 142.34

S2tot_wt*as.numeric(compartments$eqn)/(10^(-12-9) * 6.022*10^23)

```

Scale the molecules per cell data to the wild type data set of Hepa1-6
```{r}
totals <- read.csv("Totals per cell.csv") %>% 
  gather(key = "Cell_line", value = "value", -1) %>% 
  set_names(c("Protein", "Cell_line", "value"))

hepa_16_wt <- cg[1,paste0("S", 2:4, "tot")] %>% unlist

tot_234_wt <- hepa_16_wt %>% sum
tot_234_Hep1.6 <- totals %>% filter(Cell_line == "Hepa1.6") %>% extract2(3) %>% sum

scale <- tot_234_wt/tot_234_Hep1.6

newcg <- totals %>% 
  mutate(value = scale * value) %>% 
  spread(key = "Protein", value = "value") %>% 
  mutate(TGFb = 1, nExpID = 100) %>% 
  set_rownames(.[["Cell_line"]]) %>% 
  select(-1)

random_ids <- get_random(model_def) %>% c(get_random(data_def)) %>% unique
newcg_which_random <- names(newcg) %>% sapply(. %>% str_detect(random_ids)%>% any)

newcg_random <- newcg[newcg_which_random]
newcg_pars <- newcg[!(newcg_which_random|str_detect(names(newcg),"data_file"))]

trafo_list <- lapply(1:nrow(newcg), function(i) {
  
  random_id_values <- newcg_random[i,,drop = F] %>% unlist
  
  what <- paste0("\\1", names(random_id_values),  random_id_values)
  by <- paste0("([\b_]*)(?:", names(random_id_values),")([\b_]*)")
  mytrafo <-
    sapply(trafo, . %>% str_replace_all(structure(what, names = by)))
  # str_replace("abcdefg", "(ab)(?:cd)", "\\1hij") # to understand the upper regex

    
  mynewcg_pars <- newcg_pars[i,,drop = F] %>% unlist()
  
  # There are pars which are already replaced by a numeric value
  # These cannot be replaced by str_replace
  is_already_set <- sapply(names(mynewcg_pars), . %>% paste0("\b", ., "\b")%>% str_detect(mytrafo) %>% any %>% {!.})
  mytrafo <- sapply(mytrafo, . %>% str_replace_all(structure(as.character(mynewcg_pars[!is_already_set]),
                                                             names = names(mynewcg_pars[!is_already_set]))))
  mytrafo[names(mynewcg_pars[is_already_set])] <- mynewcg_pars[is_already_set]
  
  return(mytrafo)
}) %>% structure(., names = rownames(newcg))

p_grid_new <- NULL
for (i in 1:nrow(newcg)) {
  print(i)
  p_grid_new <<- p_grid_new + P(trafo_list[[i]], condition = names(trafo_list)[i])
}


```

```{r}
mypred <- (g_no_genes*x*p_grid_new)(seq(0,600,length.out = 100), pouter, deriv = F)

plotPrediction(mypred
               ) + 
  geom_line(aes(linetype = condition, color = condition))+
  # guides(color = F, linetype = F)  +
  geom_blank() +
  scale_x_continuous(breaks = 0:5*120)

ggsave("predicitions_for_different_total_smads.pdf", width = 10, height = 7)
```

```{r}
output <- mypred %>% 
  lapply(. %>% 
           as.data.frame %>% 
           gather("name", "value", -1) %>% 
           group_by(name) %>% 
           filter(value == max(value))
         ) 

lapply(seq_along(output), function(i) data.frame(output[[i]], condition = names(output)[i])) %>%
  do.call(rbind,.) %>% 
  mutate(time = round(time)) %>% 
  write_excel_csv("t_max.csv")

```





# Setting up the model
What do I to put where?
description - easy
predictor - resolveRecurrence in input-functions
compartments - don't really matter?
states - x
inputs - x
reactions - x
odes - x
derived - "variables that are derived from the dynamic and input variables"
1. resolveRecurrence to reactions 
2. g
observables - g
errors - Errormodel noch klären, estimating sigma along with it
substitutions - parameter substitutions, go into "conditions"
conditions - p
```{r}
# compile inner prediction function
myodemodel <- odemodel(f)
# saveRDS(myodemodel, file = "myodemodel.rds")
# myodemodel <- readRDS("myodelmodel.rds")

# create inner prediction function
x <- Xs(myodemodel)


# create observation function defined from observables, should be compiled
g <- Y(g = observables, f = f)


# create Parameter trafo, should be compiled
# potential pitfall: logtrafo flag
# potential pitfall: getParameters(g*x) != union(getParameters(g), getParameters(x)
# potential pitfall: init_ einbauen
conditions_trafo <- structure(getParameters((g*x)), names = getParameters((g*x)))

conditions_trafo[names(conditions)] <- conditions

# test:
pinner <- structure(runif(5,0.1,2), names = getParameters(x))
x(0:10, pinner) %>% plot()
```


# General plan

* read data.def files, analogously to model.def
* look what needs to be incorporated into the objects before initializing the dMod-objects
* Replace "init_" in parameters




all_section_headings <- c("DESCRIPTION", "PREDICTOR", "PREDICTOR-DOSERESPONSE", "INPUTS", "OBSERVABLES", "ERRORS", "SUBSTITUTIONS", "CONDITIONS")



# Test, if simplify helps







