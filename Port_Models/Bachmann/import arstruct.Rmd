---
title: "Untitled"
author: "Daniel Lill"
date: "11 July 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dMod)
library(conveniencefunctions)
library(shiny)
library(miniUI)
```

```{r}
# library(R.matlab)
# d2dresult <- readMat(c("~/Promotion/Software/d2d/arFramework3/Examples/Bachmann_MSB2011/Results/BestFit/workspace.mat"))
# saveRDS(d2dresult, "workspaceMAT.rds")
d2dresult <- readRDS("workspaceMAT.rds")
```


The best way to explore the ar struct is to print out the structure, then find the dimensions which have length 1
```{r explore ar struct, eval=FALSE}
d2dresult$ar %>% dim # answer: 38 1 1

d2dresult$ar[,1,1] %>% # take only the first dimension
# names %>% 
  str1 %>%
  {.}

# Look at model
d2dresult$ar[,1,1][["model"]][,1,1] %>%  # is a list, since again the array was of dim 50 1 1
  str1 %>%
  {.}

d2dresult$ar[,1,1][["model"]][,1,1][["fp"]] %>% 
  # str1 %>%
  {.}


d2dresult$ar[,1,1][["model"]][,1,1][1:10] %>% # rather boring
  # str2 %>%
{.}

d2dresult$ar[,1,1][["model"]][,1,1][11:20] %>% # rather boring
  # str2 %>%
{.}

d2dresult$ar[,1,1][["model"]][,1,1][21:30] %>% # rather boring
  # str2 %>%
{.}

d2dresult$ar[,1,1][["model"]][,1,1][31:40] %>% # data is interesting
  # str2 %>%
{.}


d2dresult$ar[,1,1][["model"]][,1,1][["data"]][,1,] %>% # dim 70 (1) 42
  str1 %>% 
  {.}


d2dresult$ar[,1,1][["model"]][,1,1][["data"]][1,1,] %>% # last dimension is a realization of a condition
  str1 %>% 
  {.}

d2dresult$ar[,1,1][["model"]][,1,1][["data"]][,1,] %>% # elements of one condition
  dimnames() %>% 
  {.}


# look at one condition
d2dresult$ar[,1,1][["model"]][,1,1][["data"]][,1,1] %>% # elements of one condition
  # names %>% 
  str1 %>%
  # dim %>% 
  {.}
```


# Build ode model
```{r}
mymodel <- d2dresult$ar[,1,1][["model"]][,1,1] %>%  # is a list, since again the array was of dim 50 1 1
  # str1 %>%
  {.}
mymodel %>% str1
```


```{r, eval=FALSE}
# start_letters <- mymodel %>% names %>% str_sub(end = 1) %>% sort %>% unique
# 
# mymodel[str_detect(names(mymodel), "^c")] %>% map(unlist) %>% names # 
# mymodel[str_detect(names(mymodel), "^d")] %>% map(unlist) # 
# mymodel[str_detect(names(mymodel), "^f")] %>% map(unlist)
# mymodel[str_detect(names(mymodel), "^i")] %>% map(unlist)# 
# mymodel[str_detect(names(mymodel), "^n")] %>% map(unlist) #
# mymodel[str_detect(names(mymodel), "^N")] %>% map(unlist) #
# mymodel[str_detect(names(mymodel), "^p")] %>% map(unlist)
# mymodel[str_detect(names(mymodel), "^q")] %>% map(unlist) # 
# mymodel[str_detect(names(mymodel), "^s")] %>% map(unlist) %>% names #
# mymodel[str_detect(names(mymodel), "^t")] %>% map(unlist) # 
# mymodel[str_detect(names(mymodel), "^u")] %>% map(unlist) #%>% names
# mymodel[str_detect(names(mymodel), "^v")] %>% map(unlist) #%>% names
# mymodel[str_detect(names(mymodel), "^x")] %>% map(unlist) #%>% names
```


```{r odemodel}
states <- mymodel$xNames %>% unlist %>% unname()
comp <- mymodel$c %>% unlist() %>% unname()
comp_size <- mymodel$pc %>% unlist() %>% unname() %>% as.numeric()
state_comp <- mymodel$cLink[1,] %>% factor() %>% `levels<-`(comp)
states_df <- data.frame(state = states, compartment = state_comp, volumes = comp_size[state_comp], stringsAsFactors = F)

rates <- mymodel$fv %>% unlist() %>% unname()
N <- mymodel$N
rownames(N) <- states_df$state
N[N==0] <- NA

u <- mymodel$u %>% unlist %>% unname
fu <- mymodel$fu %>% unlist %>% unname
rates <- replaceSymbols(u,fu,rates)



reactions <- eqnlist(smatrix = t(N), states = states_df$state, rates = rates, volumes = structure(states_df$volumes, names = states_df$state))

f <- odemodel(reactions, modelname = "arOdemodel", estimate = c("CIS", "CISTurn"))
x <- Xs(f)
```

```{r parameters global trafo}

# # all inner parameter names of the model
# # however, $pc is not the name of the parameter but the volume directly
# pvariables <- c("c", "u", "x", "x0")
# parnames <- map(pvariables %>% paste0("p",.) %>% setNames(.,.), function(myvar) mymodel[[myvar]] %>% unlist %>% unname)
# parnames$pc <- comp
# 
# fvariables <- c("p", "u", "v", "x")
# # map(fvariables %>% paste0("f",.) %>% setNames(.,.), function(myvar) mymodel[[myvar]] %>% unlist %>% unname)
# pareqns <- mymodel$fp %>% unlist %>% unname
# 
# # general trafo
# # order of mymodel$fp: c("pc", "px", "pu", "px0")
# inits <- parnames$px0 #%>% are_names_of(.,str_replace_all(.,"init_",""))
# parnames <- parnames[c("pc", "px", "pu", "px0")] %>% do.call(c,.) #%>% str_replace_all("^init_", "")
# 
# # fp(x0) are not of the same order as px0
# 
# 
# 
# trafo0 <-  pareqns %>% 
#   setNames(parnames)

parnames <- mymodel$p  %>% unlist %>% unname
pareqns  <- mymodel$fp %>% unlist %>% unname

# in parameter trafos, replacing "init_" by "" is not a problem, but they also appear in observation functions to normalize observations. Therefore, duplicate inits, once keeping init_ in the name, but filling both duplicates with the same value
init_ind <- parnames %>% str_detect("^init_")
init_names <- parnames[init_ind]
parnames <- parnames %>% str_replace_all("init_", "")
pareqns  <- pareqns  %>% str_replace_all("init_", "")
init_eqns <- pareqns[init_ind]

parnames <- c(parnames, init_names)
pareqns <- c(pareqns, init_eqns)


# compartment names are somehow already replaced by their values not very elegant, hardcoded and could result in problems for other models
parnames[1:length(comp)] <- comp

trafo0 <-  pareqns %>%
  setNames(parnames)

```


```{r}
mymodel[["data"]][,1,1] %>% 
  # str1
  names %>% sort

mymodel[["data"]][,1,] %>% 
  dim()

mymodel[["data"]][1,1,] %>% 
{.}
```


```{r condition}
conds <- 1:42
# i <- 1
condlist <- map(conds, function(i) {
  
mycondition <- mymodel[["data"]][,1,i]

# not very elegant
condname <- mycondition$name %>% unlist() %>% unname()

# # mycondition[str_detect(names(mycondition), "^c")] %>% map(unlist) # not interesting
# # mycondition[str_detect(names(mycondition), "^d")] %>% map(unlist) # not interesting
# mycondition[str_detect(names(mycondition), "^f")] %>% map(unlist)
# # mycondition[str_detect(names(mycondition), "^h")] %>% map(unlist)# not interesting
# mycondition[str_detect(names(mycondition), "^l")] %>% map(unlist) # a bit interesting
# mycondition[str_detect(names(mycondition), "^n")] %>% map(unlist) # a bit interesting
# mycondition[str_detect(names(mycondition), "^p")] %>% map(unlist)
# # mycondition[str_detect(names(mycondition), "^q")] %>% map(unlist) # not interesting
# # mycondition[str_detect(names(mycondition), "^s")] %>% map(unlist) %>% name # not interesting, sensitiivities
# mycondition[str_detect(names(mycondition), "^t")] %>% map(unlist) # time
# mycondition[str_detect(names(mycondition), "^y")] %>% map(unlist) #%>% names

y <- mycondition$y %>% unlist %>% unname
fy <- mycondition$fy %>% unlist %>% unname
obs <- fy %>% setNames(y)
# g <- Y(obs, x, condition = condname, modelname = paste0("ar_g_", condname))
# warning("write them out into .GlobalEnv when inside a loop to compile() them")

y <- mycondition$y %>% unlist %>% unname
fystd <- mycondition$fystd %>% unlist() %>% unname()
errors <- fystd %>% setNames(y)
# e <- Y(errors, (g*x), condition = condname, modelname = paste0("ar_e_", condname))


parnames <- mycondition$pold  %>% unlist %>% unname
pareqns  <- mycondition$fp %>% unlist %>% unname
# in parameter trafos, replacing "init_" by "" is not a problem, but they also appear in observation functions to normalize observations. Therefore, duplicate inits, once keeping init_ in the name, but filling both duplicates with the same value
init_ind <- parnames %>% str_detect("^init_")
init_names <- parnames[init_ind]
parnames_wo_init <- parnames %>% str_replace_all("init_", "")
pareqns_wo_init  <- pareqns  %>% str_replace_all("init_", "")
init_eqns <- pareqns[init_ind]

parnames <- c(parnames_wo_init, init_names)
pareqns <- c(pareqns_wo_init, init_eqns)

# compartment names are somehow already replaced by their values not very elegant, hardcoded and could result in problems for other models
parnames[1:length(comp)] <- comp

trafo <-  pareqns %>%
  setNames(parnames) %>% 
  insert("x~exp(x*log(10))", x = getSymbols(mytrafo[[i]]))

# p <- P(trafo, condition = condname, modelname = paste0("ar_p_", condname))


best_fit_values <- mycondition$pNum  %>% unlist %>% unname %>% `attr<-`("dim", NULL)
best_fit_names <- mycondition$p  %>% unlist %>% unname %>% str_replace_all("init_", "")
pars <- best_fit_values %>% log %>% `/`(log(10)) %>%  setNames(best_fit_names)




timesD <- mycondition$tExp %>% unlist() %>% unname()
yExp <- mycondition$yExp %>% `colnames<-`(y)
yExp[is.nan(yExp)] <- NA

data <- data.frame(time = timesD, sigma = NA, condition = condname, yExp) %>% 
  gather(name, value, -time, -sigma, -condition) %>% 
  filter(!is.na(value)) %>% 
  mutate(value = exp(log(10)*value)) %>% 
  as.data.frame() %>% 
  as.datalist()

# compile(g,e,p)
# remove_c_and_o()
# dMod.frame(i, g,x,p,data,e, pars = pars)

return(list(condname = condname, i = i, obs = obs, errors = errors, trafo = trafo, pars = pars, data = data))
})


### all parameters collected
all_parnames <- map(condlist, "pars") %>% do.call(c,.) %>% names %>% unique()
pars <- map(condlist, "pars") %>% map(function(i) {
  not_in_i <- all_parnames[!all_parnames%in%names(i)] %>% are_names_of(NA)
  c(i, not_in_i) %>% sort_by_name()
}) %>% 
  do.call(rbind, .) %>% 
  apply(2, . %>% .[!is.na(.)] %>% unique)

### all trafos collected
all_trafonames <- map(condlist, "trafo") %>% do.call(c,.) %>% names %>% unique()
all_trafos <- map(condlist, "trafo") %>% map(function(i) {
  not_in_i <- all_trafonames[!all_trafonames%in%names(i)] %>% are_names_of(NA)
  c(i, not_in_i) %>% sort_by_name()
}) %>% 
  do.call(rbind, .) %>% 
  apply(2, . %>% .[!is.na(.)] %>% 
          unique %>%
          {.})
varying_trafos <- all_trafos[map_lgl(all_trafos, . %>% length %>% `>`(1))] %>% .[!str_detect(names(.), "^init_")]
## select covariates and make condition names
select_covariates <- function(varying_trafos) {
  mynames <- names(varying_trafos)
  lengths <- map(varying_trafos, . %>% map_dbl(str_length) %>% max)
  
  ui <- miniPage(
    gadgetTitleBar("Select covariates"),
    miniContentPanel(
      selectInput("true_covariates", "True covariates which are not derived from other ones", mynames, mynames[lengths<=10], multiple = T),
      selectInput("derived_conds", "Derived covariates (discarded)", mynames, mynames[lengths>10], multiple = T),
      tableOutput("varying")
      )
  )
  server <- function(input, output, session) {
    # Define reactive expressions, outputs, etc.
    output$varying <- renderTable(unlist(varying_trafos) %>% data.frame(name = names(.), trafo = .) )
    # When the Done button is clicked, return a value
    observeEvent(input$done, {
      returnValue <- input$true_covariates
      stopApp(returnValue)
    })
  }
  runGadget(ui, server)
}
covs <- select_covariates(varying_trafos)


covtable <- map(condlist, "trafo") %>% map(function(i) {
  not_in_i <- all_trafonames[!all_trafonames%in%names(i)] %>% are_names_of(NA)
  c(i, not_in_i) %>% sort_by_name()
}) %>% 
  do.call(rbind, .) %>% 
  .[,covs] %>% 
  cbind(dataset = map_chr(condlist, "condname"), .)
condnames <- covtable %>% apply(1, paste0, collapse = "_")
rownames(covtable) <- condnames


### Build g, e and p and supply covtable to data
trafo <- map(condlist, "trafo") %>% `attr<-`("condition.grid", covtable) %>% `attr<-`("names", condnames)
p <- P(trafo, modelname = "ar_p")

g <- seq_along(condlist) %>% map(function(cn)
  Y(condlist[[cn]][["obs"]],x, condition = condnames[cn], modelname = "ar_g")
  ) %>% 
  Reduce("+",.)

e <- seq_along(condlist) %>% map(function(cn)
  Y(condlist[[cn]][["errors"]],x, condition = condnames[cn], modelname = "ar_g")
  ) %>% 
  Reduce("+",.)

compile(g,e,p, output = "ar_gep", cores = 4)
remove_c_and_o()

cond_no_data <-  map(condlist, "data") %>% map(1) %>% map_lgl(is.null)
data <-  map(condlist, "data") %>% map(1) %>% .[!cond_no_data] %>% as.datalist(names = condnames[!cond_no_data]) %>% `attr<-`("condition.grid", covtable[!cond_no_data,])

model <- dMod.frame("1", g,x,p,data,e) %>% appendObj(pars = list(pars))

```

```{r compare elements across conditions}

mylist <- transpose(condlist)
# mylist %>% map(function(i) {
#   try(compare(i[[1]], i[[2]]))
# })
# mylist$condname

prs <- mylist[["pars"]]

do.call(rbind, prs) %>% apply(2, . %>% unique %>% length %>% `==`(1))


```


```{r compare elements across conditions}

mylist <- transpose(condlist)
# mylist %>% map(function(i) {
#   try(compare(i[[1]], i[[2]]))
# })
# mylist$condname

prs <- mylist[["pars"]]

allpars <- prs %>% map(names) %>% do.call(c,.) %>% unique()

prs2 <- prs %>% map(function(i) {
  not_in_i <- allpars[!allpars%in%names(i)] %>% are_names_of(NA)
  c(i, not_in_i) %>% sort_by_name()
})


allpar_mat <- do.call(rbind, prs2) %>% 
  cbind(mylist$condname %>% unlist, mylist$i %>% unlist,.)

all_equal <- do.call(rbind, prs2) %>% 
  cbind(mylist$condname %>% unlist, mylist$i %>% unlist,.) %>% 
  apply(2, . %>% 
          unique %>% 
          length %>% 
          `==`(1) %>% 
          {.}) %>% 
          {.}


allpar_mat[,!all_equal] %>% colnames()
allpar_mat[,!all_equal_except_for_nas] %>% colnames()



all_equal[all_equal] %>% length()
all_equal %>% length()

# Neat: All condition specific pars have a unique name
```


```{r}
frm %>% bind_rows() %>% appendObj() %>%  plotCombined(2)
```































